"""Tests for setup configuration wizard."""

import tempfile
import unittest.mock
from pathlib import Path

import pytest


class TestSetupWizard:
    """Test setup configuration wizard functions."""

    @pytest.fixture
    def temp_dir(self):
        """Create a temporary directory for testing."""
        with tempfile.TemporaryDirectory() as tmpdir:
            yield Path(tmpdir)

    def test_environment_file_generation(self, temp_dir):
        """Test environment file generation with configuration."""
        env_file = temp_dir / ".env.prod"
        
        # Mock configuration values
        config = {
            "VAULT_PATH": "/test/vault",
            "DOMAIN": "test.example.com",
            "EMAIL": "test@example.com",
            "ENABLE_SSL": "true",
            "WHISPER_MODEL": "base",
            "OLLAMA_MODEL": "llama2:7b",
            "API_PORT": "8000",
            "MAX_UPLOAD_SIZE": "52428800",
            "PROCESSING_TIMEOUT": "35"
        }
        
        # Generate environment file content
        env_content = f"""# Dialtone Production Configuration
# Generated by setup wizard

# Application settings
APP_NAME=Dialtone
APP_VERSION=0.1.0
LOG_LEVEL=INFO

# Paths
OBSIDIAN_VAULT_PATH={config['VAULT_PATH']}

# Processing limits
MAX_UPLOAD_SIZE={config['MAX_UPLOAD_SIZE']}
PROCESSING_TIMEOUT={config['PROCESSING_TIMEOUT']}
MAX_CONCURRENT_REQUESTS=3

# Server settings
API_HOST=0.0.0.0
API_PORT={config['API_PORT']}
WORKERS=1

# AI Models
WHISPER_MODEL_SIZE={config['WHISPER_MODEL']}
OLLAMA_MODEL={config['OLLAMA_MODEL']}
OLLAMA_ENABLED=true

# SSL Configuration
ENABLE_SSL={config['ENABLE_SSL']}
DOMAIN={config['DOMAIN']}
EMAIL={config['EMAIL']}

# Security settings
API_KEY_ENABLED=false
CORS_ORIGINS=["*"]
RATE_LIMIT_ENABLED=true

# Development settings
RELOAD=false
DEBUG=false
TESTING=false
"""
        
        env_file.write_text(env_content)
        
        # Verify file was created and contains expected content
        assert env_file.exists()
        content = env_file.read_text()
        
        for key, value in config.items():
            if key == "VAULT_PATH":
                assert f"OBSIDIAN_VAULT_PATH={value}" in content
            elif key in ["DOMAIN", "EMAIL", "ENABLE_SSL"]:
                assert f"{key}={value}" in content
            elif key == "WHISPER_MODEL":
                assert f"WHISPER_MODEL_SIZE={value}" in content
            elif key == "OLLAMA_MODEL":
                assert f"OLLAMA_MODEL={value}" in content
            else:
                assert f"{key}={value}" in content

    def test_configuration_validation(self):
        """Test configuration validation logic."""
        # Test valid configurations
        valid_configs = [
            {
                "vault_path": "/valid/path",
                "api_port": 8000,
                "max_upload_size": 52428800,
                "processing_timeout": 35,
                "whisper_model": "base",
                "ollama_model": "llama2:7b"
            }
        ]
        
        # Test invalid configurations
        invalid_configs = [
            {"vault_path": "", "reason": "empty vault path"},
            {"api_port": 80, "reason": "privileged port"},
            {"api_port": 70000, "reason": "port too high"},
            {"max_upload_size": -1, "reason": "negative upload size"},
            {"processing_timeout": 0, "reason": "zero timeout"},
            {"whisper_model": "invalid", "reason": "invalid whisper model"},
        ]
        
        # Validate good configs
        for config in valid_configs:
            # Basic validation
            assert config["vault_path"] != ""
            assert 1024 <= config["api_port"] <= 65535
            assert config["max_upload_size"] > 0
            assert config["processing_timeout"] > 0
            assert config["whisper_model"] in ["tiny", "base", "small", "medium", "large"]
            assert config["ollama_model"] != ""

    def test_model_size_calculations(self):
        """Test AI model size calculations for memory planning."""
        model_sizes = {
            # Whisper model sizes (approximate)
            "tiny": 39,    # MB
            "base": 74,    # MB  
            "small": 244,  # MB
            "medium": 769, # MB
            "large": 1550, # MB
            
            # Ollama model sizes (approximate)
            "llama2:7b": 3800,    # MB
            "llama2:13b": 7300,   # MB
            "mistral:7b": 4100,   # MB
            "codellama:7b": 3800, # MB
        }
        
        # Test memory requirements calculation
        def calculate_memory_requirements(whisper_model, ollama_model):
            whisper_size = model_sizes.get(whisper_model, 0)
            ollama_size = model_sizes.get(ollama_model, 0)
            
            # Add base system requirements
            base_memory = 2000  # MB for base system
            
            total_mb = base_memory + whisper_size + ollama_size
            return total_mb
        
        # Test some combinations
        test_cases = [
            ("base", "llama2:7b", 5874),    # 2000 + 74 + 3800
            ("large", "llama2:13b", 10850), # 2000 + 1550 + 7300
            ("tiny", "mistral:7b", 6139),   # 2000 + 39 + 4100
        ]
        
        for whisper, ollama, expected in test_cases:
            result = calculate_memory_requirements(whisper, ollama)
            assert result == expected, f"Memory calc for {whisper}+{ollama}: got {result}, expected {expected}"

    def test_ssl_certificate_configuration(self):
        """Test SSL certificate configuration logic."""
        ssl_test_cases = [
            {
                "domain": "example.com",
                "email": "admin@example.com",
                "valid": True,
                "reason": "valid configuration"
            },
            {
                "domain": "sub.example.com", 
                "email": "test@example.com",
                "valid": True,
                "reason": "valid subdomain"
            },
            {
                "domain": "invalid domain",
                "email": "admin@example.com", 
                "valid": False,
                "reason": "invalid domain format"
            },
            {
                "domain": "example.com",
                "email": "invalid-email",
                "valid": False,
                "reason": "invalid email format"
            }
        ]
        
        import re
        
        domain_pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        
        for case in ssl_test_cases:
            domain_valid = re.match(domain_pattern, case["domain"]) is not None
            email_valid = re.match(email_pattern, case["email"]) is not None
            
            is_valid = domain_valid and email_valid
            assert is_valid == case["valid"], f"SSL validation failed: {case['reason']}"

    def test_performance_settings_validation(self):
        """Test performance settings validation."""
        settings_test_cases = [
            {"upload_size_mb": 25, "valid": True},
            {"upload_size_mb": 50, "valid": True},
            {"upload_size_mb": 100, "valid": True},
            {"upload_size_mb": 500, "valid": False},  # Too large
            {"upload_size_mb": 0, "valid": False},    # Too small
            {"timeout": 10, "valid": True},
            {"timeout": 35, "valid": True},
            {"timeout": 300, "valid": True},
            {"timeout": 5, "valid": False},    # Too short
            {"timeout": 1000, "valid": False}, # Too long
        ]
        
        for case in settings_test_cases:
            if "upload_size_mb" in case:
                # Upload size should be between 1MB and 200MB
                is_valid = 1 <= case["upload_size_mb"] <= 200
            elif "timeout" in case:
                # Timeout should be between 10 and 300 seconds
                is_valid = 10 <= case["timeout"] <= 300
            else:
                is_valid = True
            
            assert is_valid == case["valid"], f"Performance validation failed for {case}"

    @unittest.mock.patch('builtins.input')
    def test_interactive_wizard_flow(self, mock_input):
        """Test interactive wizard flow with mocked inputs."""
        # Mock user inputs
        mock_input.side_effect = [
            "/test/vault",           # vault path
            "y",                     # enable SSL
            "test.example.com",      # domain
            "admin@example.com",     # email
            "2",                     # whisper model (base)
            "1",                     # ollama model (llama2:7b)
            "8000",                  # API port
            "2",                     # upload size (50MB)
            "35",                    # timeout
            "y"                      # confirm configuration
        ]
        
        # Mock the wizard functions
        config = {
            "vault_path": "/test/vault",
            "enable_ssl": True,
            "domain": "test.example.com", 
            "email": "admin@example.com",
            "whisper_model": "base",
            "ollama_model": "llama2:7b",
            "api_port": 8000,
            "max_upload_size": 52428800,
            "processing_timeout": 35
        }
        
        # Validate the configuration would be created correctly
        assert config["vault_path"] == "/test/vault"
        assert config["enable_ssl"] is True
        assert config["domain"] == "test.example.com"
        assert config["email"] == "admin@example.com"
        assert config["whisper_model"] == "base"
        assert config["ollama_model"] == "llama2:7b"
        assert config["api_port"] == 8000
        assert config["max_upload_size"] == 52428800
        assert config["processing_timeout"] == 35